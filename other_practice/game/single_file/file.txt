在<<C专家编程>>里看到一个有趣的例子: 编写一个程序，把C语言的声明翻译成通俗语言。

书中的设计方案：主要数据结构是一个堆栈，先从左向右读取，把各个标记依次压入堆栈，直到读取到标识符为止。然后继续向右读入一个标记，即标识符右边的那个标记，接着，观察标识符左边的那个标记(需要从堆栈中弹出)。

书中的解决方案：
```
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#define MAXTOKENS 100
#define MAXTOKENLEN 64

enum type_tag
{
	IDENTIFIER, QUALIFIER, TYPE
};

struct token
{
	char type;
	char string[MAXTOKENLEN];//定义字符数组储存标识符
};

int top = -1;
struct token stack[MAXTOKENS];//保存第一个标识之前的所有标记
struct token this;//保存刚读入的标记 

#define pop stack[top--]
#define push(s) stack[++top] = s

enum type_tag classify_string()
{//推断标识符的类型
	char *s = this.string;
	if (!strcmp(s, "const"))
	{
		strcpy(s, "read-only");
		return QUALIFIER;
	}

	if (!strcmp(s, "volatile"))
	{
		return QUALIFIER;
	}

	if (!strcmp(s, "void"))
	{
		return TYPE;
	}

	if (!strcmp(s, "char"))
	{
		return TYPE;
	}

	if (!strcmp(s, "unsigned"))
	{
		return TYPE;
	}

	if (!strcmp(s, "short"))
	{
		return TYPE;
	}

	if (!strcmp(s, "int"))
	{
		return TYPE;
	}
	
	if (!strcmp(s, "long"))
	{
		return TYPE;
	}

	if (!strcmp(s, "float"))
	{
		return TYPE;
	}

	if (!strcmp(s, "double"))
	{
		return TYPE;
	}

	if (!strcmp(s, "struct"))
	{
		return TYPE;
	}

	if (!strcmp(s, "union"))
	{
		return TYPE;
	}

	if (!strcmp(s, "enum"))
	{
		return TYPE;
	}
	
	return IDENTIFIER;
}

void gettoken()
{//读取下一个标记到“this”
	char *p = this.string;

	while ((*p = getchar()) == " ")//略过空白字符
		;

	if (isalnum(*p))//读入的标识符以字母或数字开头
	{	
		//将标识符中的每个字符依次读入this.string中
		while(isalnum(*++p = getchar()))
			;
		ungetc(*p, stdin);//当字符不为字母或数字时，将其推入输入流
		*p = '\0';//为this.string的末尾添加空字符
		this.type = classify_string();//识别标识符的类型
		return;
	}

	if (*p == '*')
	{
		strcpy(this.string, "pointer to");
		this.type = '*';
		return;
	}
	this.string[1] = '\0';
	this.type = *p;
	return;
}

void read_to_first_identifier()
{
	gettoken();
	while (this.type != IDENTIFIER)//不为标识符则入栈，直到读取到标识符
	{
		push(this);
		gettoken();
	}
	printf("%s is ", this.string);
	gettoken();
}

void deal_with_arrays()
{
	while (this.type == '[')
	{
		printf("array ");
		gettoken();
		if (isdigit(this.string[0]))
		{
			printf("0..%d ", atoi(this.string) - 1);
		}
	gettoken();
	printf("of ");
	}
}

void deal_with_function_args()
{
	while (this.type == ')')
	{
		gettoken();
	}
	gettoken();
	printf("function returning ");
}

void deal_with_pointers()
{
	while(stack[top].type == '*')
	{
		printf("%s ", pop.string);
	}
}

void deal_with_declarator()
{//处理标识符后可能存在的数组/函数
	switch(this.type)
	{
		case '[' :
			deal_with_arrays();
			break;
		case '(' : 
			deal_with_function_args();
			break;
		default :
			break;
	}


	deal_with_pointers();
//处理在读入标识符之前压入到堆栈中的符号
	while(top >= 0)
	{
		if (stack[top].type == '(')
		{
			pop;
			gettoken();//读取')'之后的符号
			deal_with_declarator();
		}
		else
		{
			printf("%s ", pop.string);
		}
	}
}

int main()
{	//将标记压入堆栈中，直到遇见标识符
	read_to_first_identifier();
	deal_with_declarator();
	printf("\n");
	return 0;
}
```
经测试，编译通过。
linux版本：Ubuntu 18.04.5 LTS \n \l
gcc版本：gcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0

输入：
```
char * const *(*next)()
```
输出结果：
```
next is pointer to function returning pointer to   read-only   pointer to   char 

```
为了简单起见，书中程序暂且忽略了错误处理，且在处理结构、枚举和联合时只简单地用"struct", "enum", 和"union"来代表它们的具体内容。并且，程序假定函数括号内没有参数列表。

按照书中说法，这个程序是编译器中主要子系统之一的解析器（虽然不太懂）。
对程序中deal_with_declarator中递归部分仍不太理解。



